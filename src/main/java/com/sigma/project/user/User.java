package com.sigma.project.user;


import java.io.*;
import java.sql.*;
import java.util.*;
import java.math.*;

/**
 * User Value Object.
 * This class is value object representing database table User
 * This class is intented to be used together with associated Dao object.
 */

/**
 * This sourcecode has been generated by FREE DaoGen generator version 2.4.1.
 * The usage of generated code is restricted to OpenSource software projects
 * only. DaoGen is available in http://titaniclinux.net/daogen/
 * It has been programmed by Tuomo Lukka, Tuomo.Lukka@iki.fi
 *
 * DaoGen license: The following DaoGen generated source code is licensed
 * under the terms of GNU GPL license. The full text for license is available
 * in GNU project's pages: http://www.gnu.org/copyleft/gpl.html
 *
 * If you wish to use the DaoGen generator to produce code for closed-source
 * commercial applications, you must pay the lisence fee. The price is
 * 5 USD or 5 Eur for each database table, you are generating code for.
 * (That includes unlimited amount of iterations with all supported languages
 * for each database table you are paying for.) Send mail to
 * "Tuomo.Lukka@iki.fi" for more information. Thank you!
 */



public class User implements Cloneable, Serializable {

  /**
   * Persistent Instance variables. This data is directly
   * mapped to the columns of database table.
   */
  private int userId;
  private String userName;
  private String password;
  private String remarks;
  private String status;
  private java.sql.Date createdOn;
  private String createdBy;
  private java.sql.Date editedOn;
  private String editedBy;



  /**
   * Constructors. DaoGen generates two constructors by default.
   * The first one takes no arguments and provides the most simple
   * way to create object instance. The another one takes one
   * argument, which is the primary key of the corresponding table.
   */

  public User () {

  }

  public User (int userIdIn) {

    this.userId = userIdIn;

  }


  /**
   * Get- and Set-methods for persistent variables. The default
   * behaviour does not make any checks against malformed data,
   * so these might require some manual additions.
   */

  public int getUserId() {
    return this.userId;
  }
  public void setUserId(int userIdIn) {
    this.userId = userIdIn;
  }

  public String getUserName() {
    return this.userName;
  }
  public void setUserName(String userNameIn) {
    this.userName = userNameIn;
  }

  public String getPassword() {
    return this.password;
  }
  public void setPassword(String passwordIn) {
    this.password = passwordIn;
  }

  public String getRemarks() {
    return this.remarks;
  }
  public void setRemarks(String remarksIn) {
    this.remarks = remarksIn;
  }

  public String getStatus() {
    return this.status;
  }
  public void setStatus(String statusIn) {
    this.status = statusIn;
  }

  public java.sql.Date getCreatedOn() {
    return this.createdOn;
  }
  public void setCreatedOn(java.sql.Date createdOnIn) {
    this.createdOn = createdOnIn;
  }

  public String getCreatedBy() {
    return this.createdBy;
  }
  public void setCreatedBy(String createdByIn) {
    this.createdBy = createdByIn;
  }

  public java.sql.Date getEditedOn() {
    return this.editedOn;
  }
  public void setEditedOn(java.sql.Date editedOnIn) {
    this.editedOn = editedOnIn;
  }

  public String getEditedBy() {
    return this.editedBy;
  }
  public void setEditedBy(String editedByIn) {
    this.editedBy = editedByIn;
  }



  /**
   * setAll allows to set all persistent variables in one method call.
   * This is useful, when all data is available and it is needed to
   * set the initial state of this object. Note that this method will
   * directly modify instance variales, without going trough the
   * individual set-methods.
   */

  public void setAll(int userIdIn,
                     String userNameIn,
                     String passwordIn,
                     String remarksIn,
                     String statusIn,
                     java.sql.Date createdOnIn,
                     String createdByIn,
                     java.sql.Date editedOnIn,
                     String editedByIn) {
    this.userId = userIdIn;
    this.userName = userNameIn;
    this.password = passwordIn;
    this.remarks = remarksIn;
    this.status = statusIn;
    this.createdOn = createdOnIn;
    this.createdBy = createdByIn;
    this.editedOn = editedOnIn;
    this.editedBy = editedByIn;
  }


  /**
   * hasEqualMapping-method will compare two User instances
   * and return true if they contain same values in all persistent instance
   * variables. If hasEqualMapping returns true, it does not mean the objects
   * are the same instance. However it does mean that in that moment, they
   * are mapped to the same row in database.
   */
  public boolean hasEqualMapping(User valueObject) {

    if (valueObject.getUserId() != this.userId) {
      return(false);
    }
    if (this.userName == null) {
      if (valueObject.getUserName() != null)
        return(false);
    } else if (!this.userName.equals(valueObject.getUserName())) {
      return(false);
    }
    if (this.password == null) {
      if (valueObject.getPassword() != null)
        return(false);
    } else if (!this.password.equals(valueObject.getPassword())) {
      return(false);
    }
    if (this.remarks == null) {
      if (valueObject.getRemarks() != null)
        return(false);
    } else if (!this.remarks.equals(valueObject.getRemarks())) {
      return(false);
    }
    if (this.status == null) {
      if (valueObject.getStatus() != null)
        return(false);
    } else if (!this.status.equals(valueObject.getStatus())) {
      return(false);
    }
    if (this.createdOn == null) {
      if (valueObject.getCreatedOn() != null)
        return(false);
    } else if (!this.createdOn.equals(valueObject.getCreatedOn())) {
      return(false);
    }
    if (this.createdBy == null) {
      if (valueObject.getCreatedBy() != null)
        return(false);
    } else if (!this.createdBy.equals(valueObject.getCreatedBy())) {
      return(false);
    }
    if (this.editedOn == null) {
      if (valueObject.getEditedOn() != null)
        return(false);
    } else if (!this.editedOn.equals(valueObject.getEditedOn())) {
      return(false);
    }
    if (this.editedBy == null) {
      if (valueObject.getEditedBy() != null)
        return(false);
    } else if (!this.editedBy.equals(valueObject.getEditedBy())) {
      return(false);
    }

    return true;
  }



  /**
   * toString will return String object representing the state of this
   * valueObject. This is useful during application development, and
   * possibly when application is writing object states in textlog.
   */
  public String toString() {
    StringBuffer out = new StringBuffer(this.getDaogenVersion());
    out.append("\nclass User, mapping to table User\n");
    out.append("Persistent attributes: \n");
    out.append("userId = " + this.userId + "\n");
    out.append("userName = " + this.userName + "\n");
    out.append("password = " + this.password + "\n");
    out.append("remarks = " + this.remarks + "\n");
    out.append("status = " + this.status + "\n");
    out.append("createdOn = " + this.createdOn + "\n");
    out.append("createdBy = " + this.createdBy + "\n");
    out.append("editedOn = " + this.editedOn + "\n");
    out.append("editedBy = " + this.editedBy + "\n");
    return out.toString();
  }


  /**
   * Clone will return identical deep copy of this valueObject.
   * Note, that this method is different than the clone() which
   * is defined in java.lang.Object. Here, the retuned cloned object
   * will also have all its attributes cloned.
   */
  public Object clone() {
    User cloned = new User();

    cloned.setUserId(this.userId);
    if (this.userName != null)
      cloned.setUserName(new String(this.userName));
    if (this.password != null)
      cloned.setPassword(new String(this.password));
    if (this.remarks != null)
      cloned.setRemarks(new String(this.remarks));
    if (this.status != null)
      cloned.setStatus(new String(this.status));
    if (this.createdOn != null)
      cloned.setCreatedOn((java.sql.Date)this.createdOn.clone());
    if (this.createdBy != null)
      cloned.setCreatedBy(new String(this.createdBy));
    if (this.editedOn != null)
      cloned.setEditedOn((java.sql.Date)this.editedOn.clone());
    if (this.editedBy != null)
      cloned.setEditedBy(new String(this.editedBy));
    return cloned;
  }



  /**
   * getDaogenVersion will return information about
   * generator which created these sources.
   */
  public String getDaogenVersion() {
    return "DaoGen version 2.4.1";
  }

}
